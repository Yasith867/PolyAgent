import { sql, relations } from "drizzle-orm";
import { pgTable, text, varchar, serial, integer, timestamp, decimal, boolean, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Re-export chat models for the integration
export * from "./models/chat";

// Users table
export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
});

export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

// Portfolios table - user's DeFi portfolios
export const portfolios = pgTable("portfolios", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  walletAddress: text("wallet_address"),
  totalValueUsd: decimal("total_value_usd", { precision: 18, scale: 2 }).default("0"),
  dailyChange: decimal("daily_change", { precision: 8, scale: 4 }).default("0"),
  createdAt: timestamp("created_at").default(sql`CURRENT_TIMESTAMP`).notNull(),
});

export const insertPortfolioSchema = createInsertSchema(portfolios).omit({
  id: true,
  createdAt: true,
});

export type Portfolio = typeof portfolios.$inferSelect;
export type InsertPortfolio = z.infer<typeof insertPortfolioSchema>;

// Token holdings within portfolios
export const tokenHoldings = pgTable("token_holdings", {
  id: serial("id").primaryKey(),
  portfolioId: integer("portfolio_id").notNull().references(() => portfolios.id, { onDelete: "cascade" }),
  symbol: text("symbol").notNull(),
  name: text("name").notNull(),
  amount: decimal("amount", { precision: 28, scale: 18 }).notNull(),
  valueUsd: decimal("value_usd", { precision: 18, scale: 2 }).default("0"),
  priceUsd: decimal("price_usd", { precision: 18, scale: 8 }).default("0"),
  change24h: decimal("change_24h", { precision: 8, scale: 4 }).default("0"),
  logoUrl: text("logo_url"),
  contractAddress: text("contract_address"),
  protocol: text("protocol"),
  createdAt: timestamp("created_at").default(sql`CURRENT_TIMESTAMP`).notNull(),
});

export const insertTokenHoldingSchema = createInsertSchema(tokenHoldings).omit({
  id: true,
  createdAt: true,
});

export type TokenHolding = typeof tokenHoldings.$inferSelect;
export type InsertTokenHolding = z.infer<typeof insertTokenHoldingSchema>;

// AI Insights generated by the agent
export const aiInsights = pgTable("ai_insights", {
  id: serial("id").primaryKey(),
  portfolioId: integer("portfolio_id").references(() => portfolios.id, { onDelete: "cascade" }),
  type: text("type").notNull(), // 'market_analysis', 'strategy', 'risk_alert', 'opportunity'
  title: text("title").notNull(),
  content: text("content").notNull(),
  severity: text("severity").default("info"), // 'info', 'warning', 'critical', 'opportunity'
  metadata: jsonb("metadata"),
  isRead: boolean("is_read").default(false),
  createdAt: timestamp("created_at").default(sql`CURRENT_TIMESTAMP`).notNull(),
});

export const insertAiInsightSchema = createInsertSchema(aiInsights).omit({
  id: true,
  createdAt: true,
});

export type AiInsight = typeof aiInsights.$inferSelect;
export type InsertAiInsight = z.infer<typeof insertAiInsightSchema>;

// Trading strategies recommended by AI
export const strategies = pgTable("strategies", {
  id: serial("id").primaryKey(),
  portfolioId: integer("portfolio_id").references(() => portfolios.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  description: text("description").notNull(),
  type: text("type").notNull(), // 'yield_farming', 'lending', 'trading', 'liquidity_provision', 'staking'
  expectedApy: decimal("expected_apy", { precision: 8, scale: 2 }),
  riskLevel: text("risk_level").notNull(), // 'low', 'medium', 'high'
  protocol: text("protocol").notNull(),
  steps: jsonb("steps"),
  isActive: boolean("is_active").default(false),
  createdAt: timestamp("created_at").default(sql`CURRENT_TIMESTAMP`).notNull(),
});

export const insertStrategySchema = createInsertSchema(strategies).omit({
  id: true,
  createdAt: true,
});

export type Strategy = typeof strategies.$inferSelect;
export type InsertStrategy = z.infer<typeof insertStrategySchema>;

// AI Chat conversations for natural language queries
export const aiChats = pgTable("ai_chats", {
  id: serial("id").primaryKey(),
  portfolioId: integer("portfolio_id").references(() => portfolios.id, { onDelete: "cascade" }),
  role: text("role").notNull(), // 'user' or 'assistant'
  content: text("content").notNull(),
  createdAt: timestamp("created_at").default(sql`CURRENT_TIMESTAMP`).notNull(),
});

export const insertAiChatSchema = createInsertSchema(aiChats).omit({
  id: true,
  createdAt: true,
});

export type AiChat = typeof aiChats.$inferSelect;
export type InsertAiChat = z.infer<typeof insertAiChatSchema>;

// Market data cache for tokens
export const marketData = pgTable("market_data", {
  id: serial("id").primaryKey(),
  symbol: text("symbol").notNull().unique(),
  name: text("name").notNull(),
  priceUsd: decimal("price_usd", { precision: 18, scale: 8 }).notNull(),
  marketCap: decimal("market_cap", { precision: 28, scale: 2 }),
  volume24h: decimal("volume_24h", { precision: 28, scale: 2 }),
  change24h: decimal("change_24h", { precision: 8, scale: 4 }),
  change7d: decimal("change_7d", { precision: 8, scale: 4 }),
  logoUrl: text("logo_url"),
  updatedAt: timestamp("updated_at").default(sql`CURRENT_TIMESTAMP`).notNull(),
});

export const insertMarketDataSchema = createInsertSchema(marketData).omit({
  id: true,
  updatedAt: true,
});

export type MarketData = typeof marketData.$inferSelect;
export type InsertMarketData = z.infer<typeof insertMarketDataSchema>;

// Relations
export const portfoliosRelations = relations(portfolios, ({ many }) => ({
  tokenHoldings: many(tokenHoldings),
  aiInsights: many(aiInsights),
  strategies: many(strategies),
  aiChats: many(aiChats),
}));

export const tokenHoldingsRelations = relations(tokenHoldings, ({ one }) => ({
  portfolio: one(portfolios, {
    fields: [tokenHoldings.portfolioId],
    references: [portfolios.id],
  }),
}));

export const aiInsightsRelations = relations(aiInsights, ({ one }) => ({
  portfolio: one(portfolios, {
    fields: [aiInsights.portfolioId],
    references: [portfolios.id],
  }),
}));

export const strategiesRelations = relations(strategies, ({ one }) => ({
  portfolio: one(portfolios, {
    fields: [strategies.portfolioId],
    references: [portfolios.id],
  }),
}));

export const aiChatsRelations = relations(aiChats, ({ one }) => ({
  portfolio: one(portfolios, {
    fields: [aiChats.portfolioId],
    references: [portfolios.id],
  }),
}));

// API Request validation schemas
export const aiChatRequestSchema = z.object({
  portfolioId: z.number().optional(),
  message: z.string().min(1, "Message is required"),
});

export type AiChatRequest = z.infer<typeof aiChatRequestSchema>;

export const aiAnalyzeRequestSchema = z.object({
  portfolioId: z.number().optional(),
  type: z.enum(["risk", "opportunity", "market_analysis"]).optional(),
});

export type AiAnalyzeRequest = z.infer<typeof aiAnalyzeRequestSchema>;
